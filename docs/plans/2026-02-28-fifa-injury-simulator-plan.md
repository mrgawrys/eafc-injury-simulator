# FIFA Injury Simulator Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a local-only Angular web app that simulates realistic FC 25 squad injuries using real Transfermarkt data.

**Architecture:** Pure frontend Angular 21 app. A one-time Node setup script downloads CSV data (FC 25 rosters + Transfermarkt injuries), fuzzy-matches players, and outputs JSON files. The Angular app reads these JSON files, runs a daily injury probability simulation in the browser, and persists game state to localStorage.

**Tech Stack:** Angular 21 (signals, standalone, zoneless, new control flow), Spartan UI, Tailwind CSS v4, tsx (for data scripts)

> **Implementation Notes (updated during build):**
> - **No tests** — testing skipped per user preference
> - **CSV data sources changed** — the original Kaggle/GitHub URLs were dead. Actual sources:
>   - Injuries: `salimt/football-datasets` repo (`player_injuries.csv`) — needs join with `player_profiles.csv` via `player_id`
>   - Roster: `PabloJRW/FC25-Players-ETL` repo (`fc25players_10_21_2024.csv`) — columns: `first_name`, `last_name`, `common_name`, `team`, `position_short_label`, `birthdate`
> - **Download uses `curl`** instead of Node `https.get` to handle GitHub LFS redirects reliably
> - **Spartan UI** installed manually (CLI interactive prompts don't work in non-TTY) — `components.json` + theme CSS vars + path aliases set up by hand

---

## Project Structure

```
fifa-injuries/
├── scripts/                    # Data pipeline (TypeScript, run via tsx)
│   ├── download-data.ts        # Downloads CSVs from Kaggle + GitHub
│   ├── process-data.ts         # Fuzzy-matches players, outputs JSON
│   └── setup-data.ts           # Orchestrates download + process
├── src/
│   ├── app/
│   │   ├── models/
│   │   │   ├── player.ts
│   │   │   ├── injury.ts
│   │   │   └── game-state.ts
│   │   ├── services/
│   │   │   ├── storage.ts          # Abstract StorageService + LocalStorage impl
│   │   │   ├── data.ts             # Loads JSON data files
│   │   │   └── simulation.ts       # Injury simulation engine
│   │   ├── pages/
│   │   │   ├── team-selection/
│   │   │   ├── dashboard/
│   │   │   └── injury-log/
│   │   ├── components/
│   │   │   └── advance-time-dialog/
│   │   ├── app.ts
│   │   ├── app.html
│   │   └── app.routes.ts
│   └── public/
│       └── data/               # Generated JSON (gitignored)
│           ├── teams.json
│           └── injury-profiles.json
├── package.json
└── .gitignore
```

---

### Task 1: Scaffold Angular 21 Project

**Files:**
- Create: entire Angular project via CLI
- Modify: `package.json` (add data scripts)
- Modify: `.gitignore` (add data dir)

**Step 1: Create Angular project**

Run inside the existing `fifa-injuries` repo root. Use `--directory .` to scaffold in-place since the repo already exists.

```bash
ng new fifa-injuries --directory . --style tailwind --ssr false --skip-git --zoneless --test-runner vitest --file-name-style-guide 2025
```

Flags:
- `--style tailwind` — sets up Tailwind CSS v4 automatically
- `--ssr false` — no server-side rendering (pure client app)
- `--skip-git` — repo already exists
- `--zoneless` — modern change detection, no zone.js
- `--test-runner vitest` — Vitest instead of Karma
- `--file-name-style-guide 2025` — concise filenames (`app.ts` not `app.component.ts`)

**Step 2: Verify it runs**

```bash
npm start
```

Expected: App opens at `http://localhost:4200` with default Angular welcome page.

**Step 3: Update `.gitignore`**

Add to `.gitignore`:

```
# Generated data files (run npm run setup-data to populate)
src/public/data/
```

**Step 4: Add data script entries to `package.json`**

```json
{
  "scripts": {
    "setup-data": "tsx scripts/setup-data.ts",
    "download-data": "tsx scripts/download-data.ts",
    "process-data": "tsx scripts/process-data.ts"
  }
}
```

**Step 5: Install script dependencies**

```bash
npm install -D tsx csv-parse fastest-levenshtein
```

- `tsx` — run TypeScript scripts directly (no build step)
- `csv-parse` — parse downloaded CSV files
- `fastest-levenshtein` — fuzzy string matching for player names

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: scaffold Angular 21 project with Tailwind and Vitest"
```

---

### Task 2: Install and Configure Spartan UI

**Files:**
- Modify: `package.json` (new deps)
- Modify: `src/styles.css` (Spartan preset)
- Create: Spartan helm components (generated by CLI)

**Step 1: Install Spartan CLI and core**

```bash
npm install -D @spartan-ng/cli
npm install @angular/cdk @spartan-ng/ui-core
```

**Step 2: Initialize Spartan**

```bash
npx ng g @spartan-ng/cli:init
```

Follow prompts — accept defaults.

**Step 3: Generate the theme**

```bash
npx ng g @spartan-ng/cli:ui-theme
```

This creates CSS variables for light/dark mode.

**Step 4: Add Spartan CSS preset to `src/styles.css`**

After the existing Tailwind imports, add:

```css
@import "@spartan-ng/brain/hlm-tailwind-preset.css";
```

**Step 5: Generate required UI components**

```bash
npx ng g @spartan-ng/cli:ui button table dialog input select badge card label separator scroll-area icon
```

This installs brain packages from npm and copies helm (styled) components into the project.

**Step 6: Verify the dev server still runs**

```bash
npm start
```

**Step 7: Commit**

```bash
git add -A
git commit -m "feat: install Spartan UI with theme and components"
```

---

### Task 3: Data Download Script

**Files:**
- Create: `scripts/download-data.ts`

This script downloads two CSV datasets into a local `data-raw/` directory (also gitignored).

**Step 1: Create the download script**

```typescript
// scripts/download-data.ts
import { mkdirSync, existsSync, createWriteStream } from "node:fs";
import { join } from "node:path";
import { get } from "node:https";

const RAW_DIR = join(import.meta.dirname, "..", "data-raw");

const SOURCES = {
  injuries:
    "https://raw.githubusercontent.com/salimt/Transfermarkt-Football-Data-Scraping/main/data/injuries.csv",
  // FC 25 roster — SoFIFA-sourced Kaggle dataset (direct download link).
  // If this link breaks, download manually from:
  // https://www.kaggle.com/datasets/nyagami/ea-sports-fc-25-database-ratings-and-stats
  roster:
    "https://raw.githubusercontent.com/nyagami/fc25-dataset/main/fc25_players.csv",
};

function download(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = createWriteStream(dest);
    get(url, (res) => {
      if (res.statusCode === 302 || res.statusCode === 301) {
        // Follow redirect
        download(res.headers.location!, dest).then(resolve, reject);
        return;
      }
      res.pipe(file);
      file.on("finish", () => {
        file.close();
        resolve();
      });
    }).on("error", reject);
  });
}

async function main() {
  mkdirSync(RAW_DIR, { recursive: true });

  for (const [name, url] of Object.entries(SOURCES)) {
    const dest = join(RAW_DIR, `${name}.csv`);
    if (existsSync(dest)) {
      console.log(`✓ ${name}.csv already exists, skipping`);
      continue;
    }
    console.log(`↓ Downloading ${name}...`);
    await download(url, dest);
    console.log(`✓ ${name}.csv saved`);
  }
}

main().catch((err) => {
  console.error("Download failed:", err);
  process.exit(1);
});
```

**Note:** The exact Kaggle/GitHub raw URLs may need adjustment. The README will document fallback manual download instructions.

**Step 2: Add `data-raw/` to `.gitignore`**

```
data-raw/
```

**Step 3: Test the download**

```bash
npx tsx scripts/download-data.ts
```

Expected: Two CSV files appear in `data-raw/`.

**Step 4: Commit**

```bash
git add scripts/download-data.ts .gitignore
git commit -m "feat: add data download script for roster and injury CSVs"
```

---

### Task 4: Data Processing Script — Write Failing Tests

**Files:**
- Create: `scripts/process-data.ts`
- Create: `scripts/process-data.test.ts`

The processing script reads both CSVs, fuzzy-matches FC 25 players to Transfermarkt injury records, and outputs two JSON files. This is complex logic that MUST be tested per the constitution.

**Step 1: Write tests for the matching and profile-building logic**

```typescript
// scripts/process-data.test.ts
import { describe, it, expect } from "vitest";
import {
  matchPlayers,
  buildInjuryProfile,
  computeLeagueAverage,
  type RosterPlayer,
  type InjuryRecord,
} from "./process-data";

describe("matchPlayers", () => {
  const roster: RosterPlayer[] = [
    { name: "Mohamed Salah", team: "Liverpool", position: "RW", age: 32 },
    { name: "Virgil van Dijk", team: "Liverpool", position: "CB", age: 33 },
    { name: "Unknown Player", team: "Liverpool", position: "GK", age: 20 },
  ];

  const injuries: InjuryRecord[] = [
    { playerName: "Mohamed Salah", club: "Liverpool FC", season: "2022/23", injury: "Hamstring Injury", daysMissed: 14 },
    { playerName: "Mohamed Salah", club: "Liverpool FC", season: "2023/24", injury: "Muscle Injury", daysMissed: 7 },
    { playerName: "Virgil van Dijk", club: "Liverpool FC", season: "2022/23", injury: "Knee Injury", daysMissed: 30 },
  ];

  it("matches players by exact name and club substring", () => {
    const result = matchPlayers(roster, injuries);
    expect(result.get("Mohamed Salah")).toHaveLength(2);
    expect(result.get("Virgil van Dijk")).toHaveLength(1);
  });

  it("returns empty array for unmatched players", () => {
    const result = matchPlayers(roster, injuries);
    expect(result.get("Unknown Player")).toBeUndefined();
  });

  it("handles fuzzy name matching (accent/transliteration differences)", () => {
    const rosterWithAccent: RosterPlayer[] = [
      { name: "Pedri", team: "FC Barcelona", position: "CM", age: 21 },
    ];
    const injuriesWithFullName: InjuryRecord[] = [
      { playerName: "Pedro González López", club: "FC Barcelona", season: "2023/24", injury: "Hamstring Injury", daysMissed: 60 },
    ];
    // Fuzzy match should NOT match these (too different) — requires club match + close name
    const result = matchPlayers(rosterWithAccent, injuriesWithFullName);
    // Pedri -> Pedro González López is too far, should not match
    expect(result.get("Pedri")).toBeUndefined();
  });
});

describe("buildInjuryProfile", () => {
  it("computes correct per-player injury stats", () => {
    const injuries: InjuryRecord[] = [
      { playerName: "Test", club: "Club", season: "2021/22", injury: "Hamstring Injury", daysMissed: 10 },
      { playerName: "Test", club: "Club", season: "2022/23", injury: "Hamstring Injury", daysMissed: 20 },
      { playerName: "Test", club: "Club", season: "2022/23", injury: "Knee Injury", daysMissed: 30 },
      { playerName: "Test", club: "Club", season: "2023/24", injury: "Hamstring Injury", daysMissed: 15 },
    ];

    const profile = buildInjuryProfile(injuries);

    // 4 injuries across 3 seasons = ~1.33 per season
    expect(profile.injuriesPerSeason).toBeCloseTo(1.33, 1);
    // Mean of [10, 20, 30, 15] = 18.75
    expect(profile.avgDaysMissed).toBeCloseTo(18.75, 1);
    // Std dev of [10, 20, 30, 15]
    expect(profile.stdDevDaysMissed).toBeGreaterThan(0);
    // 3 hamstring, 1 knee
    expect(profile.injuryTypeWeights["Hamstring Injury"]).toBeCloseTo(0.75, 2);
    expect(profile.injuryTypeWeights["Knee Injury"]).toBeCloseTo(0.25, 2);
  });
});

describe("computeLeagueAverage", () => {
  it("computes a fallback profile from all injuries", () => {
    const allInjuries: InjuryRecord[] = [
      { playerName: "A", club: "X", season: "2022/23", injury: "Hamstring Injury", daysMissed: 10 },
      { playerName: "B", club: "Y", season: "2022/23", injury: "Knee Injury", daysMissed: 20 },
    ];
    const avg = computeLeagueAverage(allInjuries);
    expect(avg.avgDaysMissed).toBeCloseTo(15, 0);
    expect(avg.injuriesPerSeason).toBeGreaterThan(0);
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run scripts/process-data.test.ts
```

Expected: FAIL — `process-data` module doesn't export anything yet.

**Step 3: Commit**

```bash
git add scripts/process-data.test.ts
git commit -m "test: add tests for player matching and injury profile building"
```

---

### Task 5: Data Processing Script — Implementation

**Files:**
- Create: `scripts/process-data.ts`

**Step 1: Implement the processing module**

```typescript
// scripts/process-data.ts
import { readFileSync, writeFileSync, mkdirSync } from "node:fs";
import { join } from "node:path";
import { parse } from "csv-parse/sync";
import { distance } from "fastest-levenshtein";

export interface RosterPlayer {
  name: string;
  team: string;
  position: string;
  age: number;
}

export interface InjuryRecord {
  playerName: string;
  club: string;
  season: string;
  injury: string;
  daysMissed: number;
}

export interface InjuryProfile {
  injuriesPerSeason: number;
  avgDaysMissed: number;
  stdDevDaysMissed: number;
  injuryTypeWeights: Record<string, number>;
}

export interface PlayerData {
  name: string;
  position: string;
  age: number;
  injuryProfile: InjuryProfile;
}

export interface TeamData {
  name: string;
  league: string;
  players: PlayerData[];
}

// --- Matching ---

/** Match roster players to their Transfermarkt injury records */
export function matchPlayers(
  roster: RosterPlayer[],
  injuries: InjuryRecord[]
): Map<string, InjuryRecord[]> {
  const result = new Map<string, InjuryRecord[]>();

  // Group injuries by normalized club name for faster lookup
  const injuryByClub = new Map<string, InjuryRecord[]>();
  for (const inj of injuries) {
    const club = normalizeClub(inj.club);
    if (!injuryByClub.has(club)) injuryByClub.set(club, []);
    injuryByClub.get(club)!.push(inj);
  }

  for (const player of roster) {
    const normTeam = normalizeClub(player.team);

    // Find all injury records from clubs that fuzzy-match the roster club
    const candidateInjuries: InjuryRecord[] = [];
    for (const [club, injs] of injuryByClub) {
      if (clubsMatch(normTeam, club)) {
        candidateInjuries.push(...injs);
      }
    }

    // Exact name match first
    const exactMatches = candidateInjuries.filter(
      (inj) => normalizeName(inj.playerName) === normalizeName(player.name)
    );
    if (exactMatches.length > 0) {
      result.set(player.name, exactMatches);
      continue;
    }

    // Fuzzy name match — threshold: Levenshtein distance <= 3
    const fuzzyMatches = candidateInjuries.filter(
      (inj) => distance(normalizeName(inj.playerName), normalizeName(player.name)) <= 3
    );
    if (fuzzyMatches.length > 0) {
      result.set(player.name, fuzzyMatches);
    }
  }

  return result;
}

function normalizeName(name: string): string {
  return name.toLowerCase().replace(/[^a-z\s]/g, "").trim();
}

function normalizeClub(club: string): string {
  return club
    .toLowerCase()
    .replace(/\bfc\b|\bafc\b|\bcf\b|\bsc\b/g, "")
    .trim();
}

function clubsMatch(a: string, b: string): boolean {
  // Check if one contains the other, or Levenshtein is close
  return a.includes(b) || b.includes(a) || distance(a, b) <= 5;
}

// --- Profile Building ---

export function buildInjuryProfile(injuries: InjuryRecord[]): InjuryProfile {
  const seasons = new Set(injuries.map((i) => i.season));
  const daysList = injuries.map((i) => i.daysMissed);

  const injuriesPerSeason = injuries.length / seasons.size;
  const avgDaysMissed = daysList.reduce((a, b) => a + b, 0) / daysList.length;

  const variance =
    daysList.reduce((sum, d) => sum + (d - avgDaysMissed) ** 2, 0) /
    daysList.length;
  const stdDevDaysMissed = Math.sqrt(variance);

  // Injury type weights
  const typeCounts: Record<string, number> = {};
  for (const inj of injuries) {
    typeCounts[inj.injury] = (typeCounts[inj.injury] || 0) + 1;
  }
  const injuryTypeWeights: Record<string, number> = {};
  for (const [type, count] of Object.entries(typeCounts)) {
    injuryTypeWeights[type] = count / injuries.length;
  }

  return { injuriesPerSeason, avgDaysMissed, stdDevDaysMissed, injuryTypeWeights };
}

export function computeLeagueAverage(allInjuries: InjuryRecord[]): InjuryProfile {
  // Group by player to compute per-player averages
  const byPlayer = new Map<string, InjuryRecord[]>();
  for (const inj of allInjuries) {
    const key = `${inj.playerName}__${inj.club}`;
    if (!byPlayer.has(key)) byPlayer.set(key, []);
    byPlayer.get(key)!.push(inj);
  }

  const profiles = [...byPlayer.values()].map(buildInjuryProfile);

  const avg = (arr: number[]) => arr.reduce((a, b) => a + b, 0) / arr.length;

  const avgProfile: InjuryProfile = {
    injuriesPerSeason: avg(profiles.map((p) => p.injuriesPerSeason)),
    avgDaysMissed: avg(profiles.map((p) => p.avgDaysMissed)),
    stdDevDaysMissed: avg(profiles.map((p) => p.stdDevDaysMissed)),
    injuryTypeWeights: {},
  };

  // Aggregate injury type weights
  const allWeights: Record<string, number[]> = {};
  for (const p of profiles) {
    for (const [type, w] of Object.entries(p.injuryTypeWeights)) {
      if (!allWeights[type]) allWeights[type] = [];
      allWeights[type].push(w);
    }
  }
  for (const [type, weights] of Object.entries(allWeights)) {
    avgProfile.injuryTypeWeights[type] = avg(weights);
  }

  return avgProfile;
}

// --- Main (file I/O, only runs when executed directly) ---

function parseRosterCsv(csv: string): RosterPlayer[] {
  const records = parse(csv, { columns: true, skip_empty_lines: true });
  return records.map((r: Record<string, string>) => ({
    name: r["Name"] || r["name"],
    team: r["Team"] || r["team"] || r["Club"] || r["club"],
    position: r["Position"] || r["position"],
    age: parseInt(r["Age"] || r["age"], 10),
  }));
}

function parseInjuriesCsv(csv: string): InjuryRecord[] {
  const records = parse(csv, { columns: true, skip_empty_lines: true });
  return records.map((r: Record<string, string>) => ({
    playerName: r["player_name"] || r["Player"],
    club: r["club"] || r["Club"] || "",
    season: r["season"] || r["Season"] || "",
    injury: r["injury"] || r["Injury"] || "Unknown",
    daysMissed: parseInt(r["days_missed"] || r["Days"] || "0", 10) || 0,
  }));
}

async function main() {
  const RAW_DIR = join(import.meta.dirname, "..", "data-raw");
  const OUT_DIR = join(import.meta.dirname, "..", "src", "public", "data");

  const rosterCsv = readFileSync(join(RAW_DIR, "roster.csv"), "utf-8");
  const injuriesCsv = readFileSync(join(RAW_DIR, "injuries.csv"), "utf-8");

  console.log("Parsing CSVs...");
  const roster = parseRosterCsv(rosterCsv);
  const injuries = parseInjuriesCsv(injuriesCsv);
  console.log(`  ${roster.length} roster players, ${injuries.length} injury records`);

  console.log("Matching players...");
  const matches = matchPlayers(roster, injuries);
  console.log(`  Matched ${matches.size}/${roster.length} players`);

  console.log("Computing league average fallback...");
  const leagueAvg = computeLeagueAverage(injuries);

  // Group roster by team
  const teamMap = new Map<string, RosterPlayer[]>();
  for (const p of roster) {
    if (!teamMap.has(p.team)) teamMap.set(p.team, []);
    teamMap.get(p.team)!.push(p);
  }

  // Build output
  const teams: TeamData[] = [];
  const injuryProfiles: Record<string, InjuryProfile> = {};

  for (const [teamName, players] of teamMap) {
    const teamPlayers: PlayerData[] = [];
    for (const p of players) {
      const playerInjuries = matches.get(p.name);
      const profile = playerInjuries
        ? buildInjuryProfile(playerInjuries)
        : leagueAvg;

      const playerId = `${teamName}__${p.name}`;
      injuryProfiles[playerId] = profile;
      teamPlayers.push({
        name: p.name,
        position: p.position,
        age: p.age,
        injuryProfile: profile,
      });
    }
    teams.push({ name: teamName, league: "", players: teamPlayers });
  }

  mkdirSync(OUT_DIR, { recursive: true });
  writeFileSync(join(OUT_DIR, "teams.json"), JSON.stringify(teams, null, 2));
  writeFileSync(
    join(OUT_DIR, "injury-profiles.json"),
    JSON.stringify(injuryProfiles, null, 2)
  );
  console.log(`✓ Written teams.json (${teams.length} teams) and injury-profiles.json`);
}

// Only run main() when executed directly (not when imported for testing)
if (process.argv[1]?.includes("process-data")) {
  main().catch((err) => {
    console.error("Processing failed:", err);
    process.exit(1);
  });
}
```

**Step 2: Run tests to verify they pass**

```bash
npx vitest run scripts/process-data.test.ts
```

Expected: All tests PASS.

**Step 3: Commit**

```bash
git add scripts/process-data.ts
git commit -m "feat: implement data processing with fuzzy player matching"
```

---

### Task 6: Setup Data Orchestrator Script

**Files:**
- Create: `scripts/setup-data.ts`

**Step 1: Create the orchestrator**

```typescript
// scripts/setup-data.ts
import { execSync } from "node:child_process";
import { join } from "node:path";

const scriptsDir = import.meta.dirname;

console.log("=== FIFA Injury Simulator — Data Setup ===\n");

console.log("Step 1/2: Downloading data...");
execSync(`npx tsx ${join(scriptsDir, "download-data.ts")}`, { stdio: "inherit" });

console.log("\nStep 2/2: Processing data...");
execSync(`npx tsx ${join(scriptsDir, "process-data.ts")}`, { stdio: "inherit" });

console.log("\n=== Setup complete! Run 'npm start' to launch the app. ===");
```

**Step 2: Test end-to-end**

```bash
npm run setup-data
```

Expected: Downloads CSVs (or skips if exist), processes them, outputs JSON to `src/public/data/`.

**Step 3: Commit**

```bash
git add scripts/setup-data.ts
git commit -m "feat: add setup-data orchestrator script"
```

---

### Task 7: Domain Models

**Files:**
- Create: `src/app/models/player.ts`
- Create: `src/app/models/injury.ts`
- Create: `src/app/models/game-state.ts`

**Step 1: Create model files**

```typescript
// src/app/models/player.ts
export interface InjuryProfile {
  injuriesPerSeason: number;
  avgDaysMissed: number;
  stdDevDaysMissed: number;
  injuryTypeWeights: Record<string, number>;
}

export interface Player {
  name: string;
  position: string;
  age: number;
  injuryProfile: InjuryProfile;
}

export interface Team {
  name: string;
  league: string;
  players: Player[];
}
```

```typescript
// src/app/models/injury.ts
export interface Injury {
  playerId: string;       // "TeamName__PlayerName"
  playerName: string;
  type: string;           // e.g. "Hamstring Injury"
  startDate: string;      // ISO date
  returnDate: string;     // ISO date
  daysMissed: number;
}
```

```typescript
// src/app/models/game-state.ts
import type { Injury } from "./injury";

export interface GameState {
  teamName: string;
  currentDate: string;      // ISO date
  seasonStartDate: string;  // ISO date
  activeInjuries: Injury[];
  injuryHistory: Injury[];
}
```

**Step 2: Commit**

```bash
git add src/app/models/
git commit -m "feat: add domain models for player, injury, and game state"
```

---

### Task 8: Storage Service

**Files:**
- Create: `src/app/services/storage.ts`

**Step 1: Create storage service with abstract interface and localStorage implementation**

```typescript
// src/app/services/storage.ts
import { Injectable } from "@angular/core";
import type { GameState } from "../models/game-state";

const STORAGE_KEY = "fifa-injuries-game-state";

export abstract class StorageService {
  abstract getGameState(): GameState | null;
  abstract saveGameState(state: GameState): void;
  abstract clearGameState(): void;
  abstract hasActiveGame(): boolean;
}

@Injectable({ providedIn: "root" })
export class LocalStorageService extends StorageService {
  getGameState(): GameState | null {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : null;
  }

  saveGameState(state: GameState): void {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  clearGameState(): void {
    localStorage.removeItem(STORAGE_KEY);
  }

  hasActiveGame(): boolean {
    return localStorage.getItem(STORAGE_KEY) !== null;
  }
}
```

Register in `app.config.ts` (or equivalent):

```typescript
providers: [
  { provide: StorageService, useClass: LocalStorageService },
]
```

**Step 2: Commit**

```bash
git add src/app/services/storage.ts
git commit -m "feat: add storage service with localStorage implementation"
```

---

### Task 9: Data Loading Service

**Files:**
- Create: `src/app/services/data.ts`

**Step 1: Create the service that loads JSON data files**

```typescript
// src/app/services/data.ts
import { Injectable, signal } from "@angular/core";
import type { Team } from "../models/player";

@Injectable({ providedIn: "root" })
export class DataService {
  private _teams = signal<Team[]>([]);
  readonly teams = this._teams.asReadonly();

  private _loaded = signal(false);
  readonly loaded = this._loaded.asReadonly();

  async loadData(): Promise<void> {
    if (this._loaded()) return;

    const res = await fetch("/data/teams.json");
    if (!res.ok) {
      throw new Error(
        "Failed to load team data. Did you run 'npm run setup-data'?"
      );
    }
    const teams: Team[] = await res.json();
    this._teams.set(teams);
    this._loaded.set(true);
  }

  getTeam(name: string): Team | undefined {
    return this._teams().find((t) => t.name === name);
  }
}
```

**Step 2: Commit**

```bash
git add src/app/services/data.ts
git commit -m "feat: add data loading service for team JSON files"
```

---

### Task 10: Injury Simulation Engine — Write Failing Tests

**Files:**
- Create: `src/app/services/simulation.ts`
- Create: `src/app/services/simulation.spec.ts`

This is the core logic and MUST be thoroughly tested per the constitution.

**Step 1: Write comprehensive tests**

```typescript
// src/app/services/simulation.spec.ts
import { describe, it, expect, vi } from "vitest";
import { SimulationService } from "./simulation";
import type { Player, InjuryProfile } from "../models/player";
import type { Injury } from "../models/injury";

function makeProfile(overrides: Partial<InjuryProfile> = {}): InjuryProfile {
  return {
    injuriesPerSeason: 2,
    avgDaysMissed: 14,
    stdDevDaysMissed: 5,
    injuryTypeWeights: { "Hamstring Injury": 0.6, "Knee Injury": 0.4 },
    ...overrides,
  };
}

function makePlayer(name: string, profile?: Partial<InjuryProfile>): Player {
  return {
    name,
    position: "CM",
    age: 25,
    injuryProfile: makeProfile(profile),
  };
}

describe("SimulationService", () => {
  describe("simulateDay", () => {
    it("returns no injuries when RNG is above threshold", () => {
      const svc = new SimulationService();
      const player = makePlayer("Safe Player", { injuriesPerSeason: 0.5 });
      // Mock Math.random to always return 0.99 (no injury)
      vi.spyOn(Math, "random").mockReturnValue(0.99);

      const result = svc.simulateDay(
        [player],
        [],
        "TestTeam",
        "2024-09-15"
      );

      expect(result.newInjuries).toHaveLength(0);
      vi.restoreAllMocks();
    });

    it("generates an injury when RNG is below threshold", () => {
      const svc = new SimulationService();
      const player = makePlayer("Unlucky Player", { injuriesPerSeason: 10 });
      // Mock Math.random to always return 0.001 (injury guaranteed)
      vi.spyOn(Math, "random").mockReturnValue(0.001);

      const result = svc.simulateDay(
        [player],
        [],
        "TestTeam",
        "2024-09-15"
      );

      expect(result.newInjuries).toHaveLength(1);
      expect(result.newInjuries[0].playerName).toBe("Unlucky Player");
      expect(result.newInjuries[0].daysMissed).toBeGreaterThanOrEqual(1);
      vi.restoreAllMocks();
    });

    it("skips already-injured players", () => {
      const svc = new SimulationService();
      const player = makePlayer("Injured Player", { injuriesPerSeason: 365 });
      const existing: Injury = {
        playerId: "TestTeam__Injured Player",
        playerName: "Injured Player",
        type: "Knee Injury",
        startDate: "2024-09-10",
        returnDate: "2024-09-20",
        daysMissed: 10,
      };
      vi.spyOn(Math, "random").mockReturnValue(0.001);

      const result = svc.simulateDay(
        [player],
        [existing],
        "TestTeam",
        "2024-09-15"
      );

      expect(result.newInjuries).toHaveLength(0);
      vi.restoreAllMocks();
    });
  });

  describe("simulateRange", () => {
    it("processes multiple days and accumulates results", () => {
      const svc = new SimulationService();
      const player = makePlayer("Test Player", { injuriesPerSeason: 365 });
      // Always injure on day 1, then player is injured for remaining days
      let callCount = 0;
      vi.spyOn(Math, "random").mockImplementation(() => {
        callCount++;
        return callCount === 1 ? 0.0001 : 0.99;
      });

      const result = svc.simulateRange(
        [player],
        [],
        "TestTeam",
        "2024-09-01",
        "2024-09-03"
      );

      expect(result.newInjuries.length).toBeGreaterThanOrEqual(1);
      vi.restoreAllMocks();
    });

    it("recovers players whose returnDate has passed", () => {
      const svc = new SimulationService();
      const player = makePlayer("Recovering Player");
      const existing: Injury = {
        playerId: "TestTeam__Recovering Player",
        playerName: "Recovering Player",
        type: "Hamstring Injury",
        startDate: "2024-09-01",
        returnDate: "2024-09-05",
        daysMissed: 4,
      };
      vi.spyOn(Math, "random").mockReturnValue(0.99);

      const result = svc.simulateRange(
        [player],
        [existing],
        "TestTeam",
        "2024-09-05",
        "2024-09-10"
      );

      expect(result.recovered).toContain("Recovering Player");
      expect(
        result.activeInjuries.find((i) => i.playerName === "Recovering Player")
      ).toBeUndefined();
      vi.restoreAllMocks();
    });
  });

  describe("injury duration", () => {
    it("clamps duration to minimum 1 day", () => {
      const svc = new SimulationService();
      const player = makePlayer("Quick Healer", {
        injuriesPerSeason: 365,
        avgDaysMissed: 1,
        stdDevDaysMissed: 10,
      });
      vi.spyOn(Math, "random").mockReturnValue(0.0001);

      const result = svc.simulateDay(
        [player],
        [],
        "TestTeam",
        "2024-09-15"
      );

      if (result.newInjuries.length > 0) {
        expect(result.newInjuries[0].daysMissed).toBeGreaterThanOrEqual(1);
      }
      vi.restoreAllMocks();
    });
  });

  describe("injury type selection", () => {
    it("selects injury types according to weights", () => {
      const svc = new SimulationService();
      const player = makePlayer("Type Test", {
        injuriesPerSeason: 365,
        injuryTypeWeights: { "Hamstring Injury": 1.0 },
      });
      vi.spyOn(Math, "random").mockReturnValue(0.0001);

      const result = svc.simulateDay(
        [player],
        [],
        "TestTeam",
        "2024-09-15"
      );

      expect(result.newInjuries[0].type).toBe("Hamstring Injury");
      vi.restoreAllMocks();
    });
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run src/app/services/simulation.spec.ts
```

Expected: FAIL — module doesn't exist yet.

**Step 3: Commit**

```bash
git add src/app/services/simulation.spec.ts
git commit -m "test: add comprehensive tests for injury simulation engine"
```

---

### Task 11: Injury Simulation Engine — Implementation

**Files:**
- Create: `src/app/services/simulation.ts`

**Step 1: Implement the simulation service**

```typescript
// src/app/services/simulation.ts
import { Injectable } from "@angular/core";
import type { Player, InjuryProfile } from "../models/player";
import type { Injury } from "../models/injury";

export interface DayResult {
  newInjuries: Injury[];
  recovered: string[];
  activeInjuries: Injury[];
}

@Injectable({ providedIn: "root" })
export class SimulationService {
  /** Simulate a single day for all players */
  simulateDay(
    players: Player[],
    activeInjuries: Injury[],
    teamName: string,
    date: string
  ): DayResult {
    const newInjuries: Injury[] = [];
    const injuredPlayerIds = new Set(activeInjuries.map((i) => i.playerId));

    for (const player of players) {
      const playerId = `${teamName}__${player.name}`;
      if (injuredPlayerIds.has(playerId)) continue;

      const dailyProb = player.injuryProfile.injuriesPerSeason / 365;
      if (Math.random() < dailyProb) {
        const duration = this.sampleDuration(player.injuryProfile);
        const returnDate = this.addDays(date, duration);
        const type = this.sampleInjuryType(player.injuryProfile);

        newInjuries.push({
          playerId,
          playerName: player.name,
          type,
          startDate: date,
          returnDate,
          daysMissed: duration,
        });
      }
    }

    return {
      newInjuries,
      recovered: [],
      activeInjuries: [...activeInjuries, ...newInjuries],
    };
  }

  /** Simulate all days from fromDate (exclusive) to toDate (inclusive) */
  simulateRange(
    players: Player[],
    activeInjuries: Injury[],
    teamName: string,
    fromDate: string,
    toDate: string
  ): DayResult {
    let current = activeInjuries.slice();
    const allNewInjuries: Injury[] = [];
    const allRecovered = new Set<string>();

    const start = new Date(fromDate);
    const end = new Date(toDate);

    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().slice(0, 10);

      // Check recoveries
      const stillInjured: Injury[] = [];
      for (const inj of current) {
        if (inj.returnDate <= dateStr) {
          allRecovered.add(inj.playerName);
        } else {
          stillInjured.push(inj);
        }
      }
      current = stillInjured;

      // Simulate new injuries
      const dayResult = this.simulateDay(players, current, teamName, dateStr);
      allNewInjuries.push(...dayResult.newInjuries);
      current = [...current, ...dayResult.newInjuries];
    }

    return {
      newInjuries: allNewInjuries,
      recovered: [...allRecovered],
      activeInjuries: current,
    };
  }

  private sampleDuration(profile: InjuryProfile): number {
    // Box-Muller transform for normal distribution
    const u1 = Math.random();
    const u2 = Math.random();
    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    const duration = Math.round(profile.avgDaysMissed + z * profile.stdDevDaysMissed);
    return Math.max(1, duration);
  }

  private sampleInjuryType(profile: InjuryProfile): string {
    const entries = Object.entries(profile.injuryTypeWeights);
    const rand = Math.random();
    let cumulative = 0;
    for (const [type, weight] of entries) {
      cumulative += weight;
      if (rand < cumulative) return type;
    }
    return entries[entries.length - 1][0];
  }

  private addDays(date: string, days: number): string {
    const d = new Date(date);
    d.setDate(d.getDate() + days);
    return d.toISOString().slice(0, 10);
  }
}
```

**Step 2: Run tests to verify they pass**

```bash
npx vitest run src/app/services/simulation.spec.ts
```

Expected: All tests PASS.

**Step 3: Commit**

```bash
git add src/app/services/simulation.ts
git commit -m "feat: implement injury simulation engine with daily probability model"
```

---

### Task 12: App Routing and Layout Shell

**Files:**
- Modify: `src/app/app.routes.ts`
- Modify: `src/app/app.html`
- Modify: `src/app/app.ts`

**Step 1: Set up routes**

```typescript
// src/app/app.routes.ts
import { Routes } from "@angular/router";

export const routes: Routes = [
  {
    path: "",
    loadComponent: () =>
      import("./pages/team-selection/team-selection").then(
        (m) => m.TeamSelectionComponent
      ),
  },
  {
    path: "dashboard",
    loadComponent: () =>
      import("./pages/dashboard/dashboard").then(
        (m) => m.DashboardComponent
      ),
  },
  {
    path: "injury-log",
    loadComponent: () =>
      import("./pages/injury-log/injury-log").then(
        (m) => m.InjuryLogComponent
      ),
  },
];
```

**Step 2: Create app layout with header**

Update `src/app/app.html`:

```html
<div class="min-h-screen bg-background text-foreground">
  <header class="border-b px-6 py-4">
    <h1 class="text-xl font-bold tracking-tight">FIFA Injury Simulator</h1>
  </header>
  <main class="mx-auto max-w-5xl px-6 py-8">
    <router-outlet />
  </main>
</div>
```

Update `src/app/app.ts` imports to include `RouterOutlet`.

**Step 3: Create placeholder page components**

Create minimal placeholder components for each page so routes resolve:

- `src/app/pages/team-selection/team-selection.ts` — `<p>Team Selection</p>`
- `src/app/pages/dashboard/dashboard.ts` — `<p>Dashboard</p>`
- `src/app/pages/injury-log/injury-log.ts` — `<p>Injury Log</p>`

Each is a standalone component with just enough to render.

**Step 4: Verify routing works**

```bash
npm start
```

Navigate to `/`, `/dashboard`, `/injury-log` — each should show placeholder text.

**Step 5: Commit**

```bash
git add src/app/
git commit -m "feat: add app layout shell with routing to three pages"
```

---

### Task 13: Team Selection Page

**Files:**
- Modify: `src/app/pages/team-selection/team-selection.ts`
- Create: `src/app/pages/team-selection/team-selection.html`

**Step 1: Implement team selection component**

This page loads team data, shows a searchable list grouped by league, and lets the user pick a team to start a season.

Key elements:
- Text input for filtering teams (Spartan `hlmInput`)
- List of teams as cards (Spartan card components)
- On team select: initialize game state with today as season start, navigate to `/dashboard`
- If a game is already active (via `StorageService.hasActiveGame()`), show a "Continue" button and a "New Season" button

The component should:
1. Inject `DataService`, `StorageService`, `Router`
2. Call `dataService.loadData()` in an `effect` or `ngOnInit`
3. Use a `computed` signal to filter teams based on search input
4. On team click: create initial `GameState`, save via `StorageService`, navigate to dashboard

**Step 2: Verify it works**

```bash
npm start
```

Navigate to `/`. Should show team list (requires data files from `npm run setup-data`).

**Step 3: Commit**

```bash
git add src/app/pages/team-selection/
git commit -m "feat: implement team selection page with search and season init"
```

---

### Task 14: Squad Dashboard Page

**Files:**
- Modify: `src/app/pages/dashboard/dashboard.ts`
- Create: `src/app/pages/dashboard/dashboard.html`

**Step 1: Implement the dashboard component**

This is the main screen. It shows:
- Current in-game date (prominent)
- Squad table with columns: Name, Position, Age, Status, Details
- Status column uses Spartan badges:
  - Green "Available" badge for healthy players
  - Red "Injured" badge for injured players (with injury type)
  - Yellow "Returning Soon" badge for players returning within 3 days
- "Advance Time" button → opens advance-time dialog (Task 15)
- "Injury Log" link → navigates to `/injury-log`
- "New Season" button → clears game state, navigates to `/`

The component should:
1. Inject `StorageService`, `DataService`, `Router`
2. Load game state and team data
3. Use `computed` signals to merge player list with active injuries
4. Redirect to `/` if no active game

**Step 2: Verify it works**

```bash
npm start
```

Select a team → should see squad dashboard with all players showing "Available".

**Step 3: Commit**

```bash
git add src/app/pages/dashboard/
git commit -m "feat: implement squad dashboard with player status table"
```

---

### Task 15: Advance Time Dialog

**Files:**
- Create: `src/app/components/advance-time-dialog/advance-time-dialog.ts`
- Create: `src/app/components/advance-time-dialog/advance-time-dialog.html`

**Step 1: Implement the dialog component**

Uses Spartan dialog components. Contains:
- Two tabs/sections: "Advance to Date" (date input) and "Next Match" (button)
- "Next Match" advances by 3 days from current date
- On confirm: calls `SimulationService.simulateRange()`, updates game state via `StorageService`
- Shows results summary after simulation:
  - List of new injuries (player, type, days out)
  - List of recovered players
  - Count of available vs injured players
- "Close" button dismisses dialog

The component should:
1. Accept current game state as input (via dialog data or input signals)
2. Run simulation on confirm
3. Emit updated game state back to dashboard
4. Dashboard updates its display after dialog closes

**Step 2: Wire dialog into dashboard**

Add an "Advance Time" button to the dashboard that opens this dialog.

**Step 3: Verify end-to-end flow**

```bash
npm start
```

Select team → dashboard → click "Advance Time" → pick date → see simulation results → dashboard updates.

**Step 4: Commit**

```bash
git add src/app/components/advance-time-dialog/
git commit -m "feat: implement advance time dialog with simulation results"
```

---

### Task 16: Injury Log Page

**Files:**
- Modify: `src/app/pages/injury-log/injury-log.ts`
- Create: `src/app/pages/injury-log/injury-log.html`

**Step 1: Implement the injury log component**

Shows the full injury history table using Spartan table components:
- Columns: Player, Injury Type, Date Injured, Days Missed, Return Date
- Sorted by date (most recent first)
- "Back to Dashboard" button

Data comes from `gameState.injuryHistory` via `StorageService`.

**Step 2: Verify it works**

Advance time a few times to generate injuries, then view injury log.

**Step 3: Commit**

```bash
git add src/app/pages/injury-log/
git commit -m "feat: implement injury log page with history table"
```

---

### Task 17: README with Setup Instructions

**Files:**
- Create: `README.md`

**Step 1: Write README**

Cover:
- What this app does (1-2 sentences)
- Prerequisites: Node 20+, npm
- Setup: `npm install` then `npm run setup-data` (explain what it downloads)
- Manual data download fallback (Kaggle links if auto-download fails)
- Run: `npm start`
- How to play: select team, advance time, manage injuries

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add README with setup and usage instructions"
```

---

### Task 18: Final Integration Test

**Files:** None (manual verification)

**Step 1: Clean run from scratch**

```bash
rm -rf node_modules src/public/data data-raw
npm install
npm run setup-data
npm start
```

**Step 2: Walk through the full flow**

1. App loads at `/` → team selection page appears
2. Search for "Liverpool" → select Liverpool
3. Dashboard shows full squad, all "Available", date set to today
4. Click "Advance Time" → "Next Match" → see simulation results
5. Some players may be injured → dashboard shows red badges
6. Advance a few more times → injuries accumulate, some players recover
7. Click "Injury Log" → see full history
8. Click "New Season" → returns to team selection
9. Refresh browser → game state persists (still on dashboard with same state)

**Step 3: Run all tests**

```bash
npx vitest run
```

Expected: All tests pass.

**Step 4: Final commit**

```bash
git add -A
git commit -m "chore: final integration verification"
```
