# FIFA Injury Simulator — Design Document

## Overview

A local-only web app that simulates realistic injuries for FC 25 squads based on real Transfermarkt injury data. Used when playing FIFA with a friend to determine which players are injured before each match.

## Problem

Previously tracked injuries via an Excel sheet with manual susceptibility scores (1-5) and rough Premier League injury statistics. The model was basic and tedious to maintain.

## Solution

An Angular web app that:
- Loads real FC 25 squad rosters and real player injury histories
- Simulates injuries using per-player statistical profiles
- Persists game state locally across sessions
- Shows squad status with clear injury/recovery information

## Tech Stack

- **Framework:** Angular 19+ (standalone components, signals, `@if`/`@for` control flow)
- **UI:** Spartan UI (Angular shadcn port) + Tailwind CSS
- **Persistence:** localStorage (behind abstracted `StorageService` interface)
- **Data:** Static JSON files generated by a setup script (not committed to repo)
- **Build:** Vite (via Angular CLI)

## Data Pipeline

### Sources

1. **FC 25 Rosters:** SoFIFA-based Kaggle dataset (CSV with player names, clubs, positions, ages)
2. **Injury Histories:** `salimt/football-datasets` GitHub repo (143k records from Transfermarkt — player_id, injury_reason, from_date, end_date, days_missed, games_missed)

### Setup Flow

1. User runs `npm run setup-data`
2. Script downloads both CSV datasets
3. Script fuzzy-matches FC 25 player names to Transfermarkt records (using name + club + age for disambiguation)
4. Outputs processed JSON files to `public/data/`:
   - `teams.json` — team → players mapping with positions, ages
   - `injury-profiles.json` — per-player injury statistics
5. `data/` directory is `.gitignore`'d

### Player Matching

- Primary match: exact name + same club
- Fallback: fuzzy name match (Levenshtein distance) + age within 1 year
- Unmatched players: assigned league-average injury profile

## Injury Simulation Model

### Per-Player Profile (derived from Transfermarkt data)

- `injuriesPerSeason`: total career injuries ÷ seasons active
- `avgDaysMissed`: mean days out per injury
- `stdDevDaysMissed`: standard deviation of days out
- `injuryTypeWeights`: distribution of injury types (e.g., 40% hamstring, 20% knee, etc.)

### Daily Simulation

- **Injury probability:** `P(injury on day) = injuriesPerSeason / 365`
- **When advancing from date A to date B:** for each day, for each healthy player, roll against their daily probability
- **If injured:** sample duration from `N(avgDaysMissed, stdDevDaysMissed)`, clamped to minimum 1 day
- **Injury type:** randomly selected weighted by `injuryTypeWeights`
- **Recovery:** player has a `returnDate`; checked each simulation step

### Fallback Profile

Players without matched injury data get a league-average profile computed from the full Transfermarkt dataset.

## App Screens

### 1. Team Selection

- Search/filter FC 25 teams by league and name
- Select a team to start a new season
- Sets the season start date

### 2. Squad Dashboard (Main Screen)

- All players listed with: name, position, age
- Status indicators: Available (green) / Injured (red) / Returning soon (yellow)
- Injured players show: injury type + expected return date
- Current in-game date displayed prominently
- Actions: "Advance Time" and "View Injury Log"

### 3. Advance Time

Two modes:
- **Date picker:** advance to a specific date
- **Next match:** advance by configurable match interval (~3-4 days)

After simulation, a summary modal shows:
- New injuries (who, what, how long)
- Recovered players
- Current squad availability count

### 4. Injury Log

Chronological history of all injuries during the season:
- Player name, injury type, date injured, days missed, return date
- Sortable/filterable

## Game State

Stored in localStorage via abstracted `StorageService`:

```typescript
interface GameState {
  teamId: string;
  currentDate: string; // ISO date
  seasonStartDate: string; // ISO date
  activeInjuries: Injury[];
  injuryHistory: Injury[];
}

interface Injury {
  playerId: string;
  playerName: string;
  type: string;
  startDate: string;
  returnDate: string;
  daysMissed: number;
}
```

## Storage Abstraction

```typescript
interface StorageService {
  getGameState(): GameState | null;
  saveGameState(state: GameState): void;
  clearGameState(): void;
  hasActiveGame(): boolean;
}
```

Initial implementation: `LocalStorageService`. Interface allows future swap to API-backed storage.

## Game Flow

1. User selects a team → game state initialized with season start date
2. User advances time (date or "next match") → simulation runs
3. Results shown → squad dashboard updates
4. Repeat for each match day throughout the season
5. Single save slot — can reset to start a new season

## Non-Goals (for v1)

- No multiplayer / two-team tracking
- No manual susceptibility overrides
- No position-based injury modifiers
- No live data refresh (static data only)
- No backend server
